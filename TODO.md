Name: 

TDD TODO/Task list

**Build Tests**

These are for implementing the EscapeGameBuilder's `makeGameManager()` method.

| **#** | Test                                                                                                                        | Comments                                                                                                   |
|:-----:|:----------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------|
|   1   | Build game manager 2 X 2, 2 players, and coordinate type SQUARE                                                             | create game object                                                                                         |
|   2   | Build game with one CLEAR [default]  location                                                                               | create game object                                                                                         |
|   3   | Build game manager 3 X 3 with 2 players and coordinate type HEX                                                             | test alternative board size and coordinate type                                                            |
|   4   | Build game manager with missing players list                                                                                | verify that missing players default to an empty list                                                       |
|   5   | Build game manager with multiple location initializers                                                                      | confirm multiple locations are processed correctly                                                         |
|   6   | Build game manager with an extra BLOCKED location initializer                                                               | test alternate location type handling                                                                      |
|   7   | Build game manager with defined piece type descriptors                                                                      | ensure piece types are configured correctly                                                                |
|   8   | Build game manager with defined rule descriptors                                                                            | ensure game rules are parsed correctly                                                                     |
|   9   | Build game manager with an empty rule descriptor array                                                                      | check that absence of rules is handled without errors                                                      |
|  10   | Build game manager with maximum board dimensions                                                                            | verify extreme board sizes are handled properly                                                            |
|  11   | Build game manager with non-square board dimensions                                                                         | confirm rectangular board initialization                                                                   |
|  12   | Build game manager with coordinate type OCTAGON (if supported)                                                              | test alternate coordinate type usage                                                                       |
|  13   | Build game manager and simulate a dummy move                                                                                | ensure move method linkage without full implementation                                                     |
|  14   | Build game manager with null location initializers                                                                          | verify that null location data is safely handled                                                           |
|  15   | Build game manager with infinite board (xMax and yMax = 0)                                                                  | Verify that an infinite board is correctly handled when xMax and yMax are 0 (accepts all positive indices) |
|  16   | Verify that coordinates outside typical bounds are valid on an infinite board                                               | Verify that coordinates outside typical bounds are valid on an infinite board                              |
|  17   | Verify that coordinates outside typical bounds are valid on an infinite board                                               | Ensure that only positive indices are allowed in Milestone2                                                |
|  18   | Ensure that only positive indices are allowed in Milestone2                                                                 | Test a straight-line (horizontal or vertical) move within distance (e.g., SNAIL moving 1 step).            |
|  19   | Test a straight-line (horizontal or vertical) move within distance (e.g., SNAIL moving 1 step).                             | Test a straight-line (horizontal or vertical) move within distance (e.g., SNAIL moving 1 step).            |
|  20   | Simulate a valid move for a flying piece despite blocked intermediate squares                                               | Confirm that a piece with the FLY attribute ignores obstructions in its straight-line path.                |
|  21   | Simulate an invalid move for a flying piece due to distance violation                                                       | Verify that even flying pieces cannot exceed their defined maximum movement distance.                      |
|  22   | Verify turn order changes on a valid move                                                                                   | Ensure that the player turn advances after a valid move is made.                                           |
|  23   | Verify turn order does not change on an invalid move                                                                        | Ensure that if a move is invalid, the same player gets another chance.                                     |
|  24   | Simulate multiple sequential moves and verify game state updates                                                            | Check overall consistency of the game state after several moves                                            |
|  25   | Verify that after a valid move, the piece is no longer at its original location                                             | Confirm that the board correctly updates piece positions.                                                  |
|  26   | Verify that a move to an already occupied square is rejected                                                                | Confirm that destination occupancy causes an invalid move (since POINT_CONFLICT is not yet supported).     |
|  27   | Verify that the piece's distance attribute is correctly enforced                                                            | Test that moves exceeding the allowed distance are rejected.                                               |
|  28   | Verify that the piece's fly attribute is recognized correctly                                                               | Test that the FLY attribute permits bypassing intermediate obstructions.                                   |
|  29   | Verify that attempting to move from an empty cell returns an invalid move                                                   | Check that if no piece exists at the starting coordinate, the move is invalid.                             |
|  30   | Verify that a linear move with negative indices is accepted on a HEX board                                                  | Use the HEX test for linearValidNegativeIndex to confirm negative-index moves work.                        |
|  31   | Verify that a linear move exceeding the allowed distance is rejected on a HEX board	                                        | Use the HEX test for linearInvalidDistance.                                                                |
|  32   | Verify that moving onto a BLOCK location is rejected on a HEX board	                                                        | Confirm via moveOntoBlockedLocation test that destinations with BLOCK type are not allowed.                |
|  33   | Verify that a flying piece can legally move over a BLOCK location on a HEX board	                                           | Use moveOverBlockedLocationValidMove test to ensure flying pieces ignore BLOCK cells.                      |
|  34   | Verify that moving over or onto an EXIT location causes the piece to exit on a HEX board	                                   | Use testMoveOntoExitLocationExitsPiece and testMoveOverExitLocationExitsPiece tests.                       |
|  35   | Verify that the SCORE rule is applied correctly when pieces exit on a HEX board	                                            | Use testSCOREGameRule to ensure score updates trigger game-end conditions appropriately.                   |
|  36   | Verify that when the next player has no legal moves, the game end condition is triggered on HEX	                            | Use testPlayerCantMakeMove to confirm that lack of legal moves leads to game end (WIN outcome).            |
|  37   | Verify that when a player has no pieces left, the game end condition is triggered on HEX board	                             | Use testPlayerNoPieceEndGame2 to check that absence of pieces causes game end.                             |
|  38   | Verify that after a valid move, the board updates the piece’s position correctly on a HEX board	                            | Confirm via various HEX tests (e.g., linearValidDistance) that the piece’s new location is correct.        |
|  39   | Verify that a valid diagonal move on a SQUARE board is accepted	                                                            | Use diagonalMoveValid test from SQUARE.                                                                    |
|  40   | Verify that a diagonal move exceeding allowed distance is rejected on a SQUARE board	                                       | Use diagonalMoveInValidDistance test from SQUARE.                                                          |
|  41   | Verify that moving from an empty cell on a SQUARE board returns an invalid move	                                            | Use the emptyLocation test from SQUARE.                                                                    |
|  42   | Verify that moving to an already occupied cell on a SQUARE board returns an invalid move	                                   | Use the targetLocationOccupied test from SQUARE.                                                           |
|  43   | Verify that moves not matching the piece’s movement pattern (e.g., orthogonal vs. diagonal) are rejected on a SQUARE board	 | Use orthogonalInvalidDiagonal and diagonalInvalidOrthogonal tests from SQUARE.                             |
|  44   | Verify that turn order remains unchanged after an invalid move on a SQUARE board	                                           | Add a test that makes an invalid move and then checks that the same player is still active.                |
|  45   | Verify that multiple sequential moves on a SQUARE board update the game state consistently	                                 | Add a test simulating a series of moves to check overall game state consistency.                           |

