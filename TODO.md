Name: 

TDD TODO/Task list

**Build Tests**

These are for implementing the EscapeGameBuilder's `makeGameManager()` method.

| **#** | Test                                                                                                                                                                  | Comments                                                                                                     |
|:-----:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------|
|   1   | Build game manager 2 X 2, 2 players, and coordinate type SQUARE                                                                                                       | create game object                                                                                           |
|   2   | Build game with one CLEAR [default]  location                                                                                                                         | create game object                                                                                           |
|   3   | Build game manager 3 X 3 with 2 players and coordinate type HEX                                                                                                       | test alternative board size and coordinate type                                                              |
|   4   | Build game manager with missing players list                                                                                                                          | verify that missing players default to an empty list                                                         |
|   5   | Build game manager with multiple location initializers                                                                                                                | confirm multiple locations are processed correctly                                                           |
|   6   | Build game manager with an extra BLOCKED location initializer                                                                                                         | test alternate location type handling                                                                        |
|   7   | Build game manager with defined piece type descriptors                                                                                                                | ensure piece types are configured correctly                                                                  |
|   8   | Build game manager with defined rule descriptors                                                                                                                      | ensure game rules are parsed correctly                                                                       |
|   9   | Build game manager with an empty rule descriptor array                                                                                                                | check that absence of rules is handled without errors                                                        |
|  10   | Build game manager with maximum board dimensions                                                                                                                      | verify extreme board sizes are handled properly                                                              |
|  11   | Build game manager with non-square board dimensions                                                                                                                   | confirm rectangular board initialization                                                                     |
|  12   | Build game manager with coordinate type OCTAGON (if supported)                                                                                                        | test alternate coordinate type usage                                                                         |
|  13   | Build game manager and simulate a dummy move                                                                                                                          | ensure move method linkage without full implementation                                                       |
|  14   | Build game manager with null location initializers                                                                                                                    | verify that null location data is safely handled                                                             |
|  15   | Build game manager with infinite board (xMax and yMax = 0)                                                                                                            | Verify that an infinite board is correctly handled when xMax and yMax are 0 (accepts all positive indices)   |
|  16   | Verify that coordinates outside typical bounds are valid on an infinite board                                                                                         | Verify that coordinates outside typical bounds are valid on an infinite board                                |
|  17   | Verify that coordinates outside typical bounds are valid on an infinite board                                                                                         | Ensure that only positive indices are allowed in Milestone2                                                  |
|  18   | Ensure that only positive indices are allowed in Milestone2                                                                                                           | Test a straight-line (horizontal or vertical) move within distance (e.g., SNAIL moving 1 step).              |
|  19   | Test a straight-line (horizontal or vertical) move within distance (e.g., SNAIL moving 1 step).                                                                       | Test a straight-line (horizontal or vertical) move within distance (e.g., SNAIL moving 1 step).              |
|  20   | Simulate a valid move for a flying piece despite blocked intermediate squares                                                                                         | Confirm that a piece with the FLY attribute ignores obstructions in its straight-line path.                  |
|  21   | Simulate an invalid move for a flying piece due to distance violation                                                                                                 | Verify that even flying pieces cannot exceed their defined maximum movement distance.                        |
|  22   | Verify turn order changes on a valid move                                                                                                                             | Ensure that the player turn advances after a valid move is made.                                             |
|  23   | Verify turn order does not change on an invalid move                                                                                                                  | Ensure that if a move is invalid, the same player gets another chance.                                       |
|  24   | Simulate multiple sequential moves and verify game state updates                                                                                                      | Check overall consistency of the game state after several moves                                              |
|  25   | Verify that after a valid move, the piece is no longer at its original location                                                                                       | Confirm that the board correctly updates piece positions.                                                    |
|  26   | Verify that a move to an already occupied square is rejected                                                                                                          | Confirm that destination occupancy causes an invalid move (since POINT_CONFLICT is not yet supported).       |
|  27   | Verify that the piece's distance attribute is correctly enforced                                                                                                      | Test that moves exceeding the allowed distance are rejected.                                                 |
|  28   | Verify that the piece's fly attribute is recognized correctly                                                                                                         | Test that the FLY attribute permits bypassing intermediate obstructions.                                     |
|  29   | Verify that attempting to move from an empty cell returns an invalid move                                                                                             | Check that if no piece exists at the starting coordinate, the move is invalid.                               |
|  30   | Verify that a linear move with negative indices is accepted on a HEX board                                                                                            | Use the HEX test for linearValidNegativeIndex to confirm negative-index moves work.                          |
|  31   | Verify that a linear move exceeding the allowed distance is rejected on a HEX board	                                                                                  | Use the HEX test for linearInvalidDistance.                                                                  |
|  32   | Verify that moving onto a BLOCK location is rejected on a HEX board	                                                                                                  | Confirm via moveOntoBlockedLocation test that destinations with BLOCK type are not allowed.                  |
|  33   | Verify that a flying piece can legally move over a BLOCK location on a HEX board	                                                                                     | Use moveOverBlockedLocationValidMove test to ensure flying pieces ignore BLOCK cells.                        |
|  34   | Verify that moving over or onto an EXIT location causes the piece to exit on a HEX board	                                                                             | Use testMoveOntoExitLocationExitsPiece and testMoveOverExitLocationExitsPiece tests.                         |
|  35   | Verify that the SCORE rule is applied correctly when pieces exit on a HEX board	                                                                                      | Use testSCOREGameRule to ensure score updates trigger game-end conditions appropriately.                     |
|  36   | Verify that when the next player has no legal moves, the game end condition is triggered on HEX	                                                                      | Use testPlayerCantMakeMove to confirm that lack of legal moves leads to game end (WIN outcome).              |
|  37   | Verify that when a player has no pieces left, the game end condition is triggered on HEX board	                                                                       | Use testPlayerNoPieceEndGame2 to check that absence of pieces causes game end.                               |
|  38   | Verify that after a valid move, the board updates the piece’s position correctly on a HEX board	                                                                      | Confirm via various HEX tests (e.g., linearValidDistance) that the piece’s new location is correct.          |
|  39   | Verify that a valid diagonal move on a SQUARE board is accepted	                                                                                                      | Use diagonalMoveValid test from SQUARE.                                                                      |
|  40   | Verify that a diagonal move exceeding allowed distance is rejected on a SQUARE board	                                                                                 | Use diagonalMoveInValidDistance test from SQUARE.                                                            |
|  41   | Verify that moving from an empty cell on a SQUARE board returns an invalid move	                                                                                      | Use the emptyLocation test from SQUARE.                                                                      |
|  42   | Verify that moving to an already occupied cell on a SQUARE board returns an invalid move	                                                                             | Use the targetLocationOccupied test from SQUARE.                                                             |
|  43   | Verify that moves not matching the piece’s movement pattern (e.g., orthogonal vs. diagonal) are rejected on a SQUARE board	                                           | Use orthogonalInvalidDiagonal and diagonalInvalidOrthogonal tests from SQUARE.                               |
|  44   | Verify that turn order remains unchanged after an invalid move on a SQUARE board	                                                                                     | Add a test that makes an invalid move and then checks that the same player is still active.                  |
|  45   | Verify that multiple sequential moves on a SQUARE board update the game state consistently	                                                                           | Add a test simulating a series of moves to check overall game state consistency.                             |
|  46   | Simulate a conflict on a HEX board where the attacker loses (attacker’s VALUE < defender’s) and verify the attacker is removed.	                                      | Check that attacker removal occurs and defender’s VALUE is reduced.                                          |
|  47   | Verify that the SCORE rule is applied correctly on a HEX board when a piece exits.	                                                                                   | Simulate moves so that one player's score reaches the SCORE threshold, and the game ends with a WIN outcome. |
|  48   | Verify that the TURN_LIMIT rule is applied on a HEX board (game ends when the move count reaches the limit).	                                                         | Simulate enough moves to trigger TURN_LIMIT and check the outcome.                                           |
|  49   | Verify that when the next player has no legal moves on a HEX board, the game end condition is triggered.	                                                             | Ensure that if the next player can’t move, the game ends with a non-NONE move result.                        |
|  50   | Verify that when a player has no pieces left on the HEX board, the game end condition is triggered.	                                                                  | Check that the game ends when one player's pieces are all removed.                                           |
|  51   | Verify that after a valid move on a HEX board, the piece’s new position is updated correctly.	                                                                        | Confirm that board piece positions are updated after a move.                                                 |
|  52   | Verify that a move from an empty cell on a HEX board returns an invalid move.	                                                                                        | Test that if no piece is at the source, the move is invalid.                                                 |
|  53   | Verify that a move to an already occupied cell on a HEX board returns an invalid move (unless conflict resolution applies).	                                          | Check that occupancy is handled correctly on HEX.                                                            |
|  54   | Verify that a HEX piece with the FLY attribute ignores obstacles along the move path.	                                                                                | Ensure that the FLY attribute allows a valid move despite intermediate obstacles.                            |
|  55   | Verify that a HEX piece without the FLY attribute is blocked by obstacles.	                                                                                           | Confirm that intermediate BLOCK or occupied cells block a non-FLY move.                                      |
|  56   | Verify that observer messages are generated when a move results in a conflict (draw, win, or loss) on a HEX board.	                                                   | Ensure that observer notifications are sent during conflict resolution.                                      |
|  57   | Verify that observer messages are generated when a SCORE rule is met on a HEX board.	                                                                                 | Confirm that observers receive extra messages when the game ends due to SCORE.                               |
|  58   | Verify that observer messages are generated when the TURN_LIMIT rule is reached on a HEX board.	                                                                      | Check that extra messages are sent when the game ends due to TURN_LIMIT.                                     |
|  59   | Simulate a series of moves on a HEX board and verify that the overall game state (piece positions, scores, turn order) is updated consistently.	                      | Test for consistency after multiple sequential moves.                                                        |
|  60   | Verify that the GameStatus returned by a move has isMoreInformation() true when extra observer messages are sent (e.g., for conflict resolution or game-end events).	 | Ensure that the final GameStatus correctly reflects that extra information was provided.                     |

